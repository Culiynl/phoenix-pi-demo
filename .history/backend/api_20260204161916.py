import os
import shutil
import json
import threading
from fastapi import FastAPI, HTTPException, UploadFile, File, Form, BackgroundTasks
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

from config import IMG_DIR, BASE_DIR, DATA_DIR, PROJECTS_DIR 
from schemas import (
    DiseaseQuery, TargetRequest, RetroRequest, 
    DockingRequest, FeudalRequest, ParetoRequest
)
from state import training_state
# Import Services
from services.llm_service import review_literature
from services.bio_service import RetroManager, fetch_chembl_data
from services.training_runner import run_training_task
from services.docking_service import DockingManager
from services.feudal_service import FeudalOptimizationManager 
from services.analysis_service import calculate_pareto_winner

app = FastAPI()

app.mount("/static", StaticFiles(directory=DATA_DIR), name="static")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/api/review")
async def api_review_literature(query: DiseaseQuery):
    try:
        return review_literature(query)
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chembl/download")
async def api_get_chembl_data(req: TargetRequest):
    data = fetch_chembl_data(req.target_name)
    if not data:
        raise HTTPException(404, "Target not found or ChEMBL unavailable")
    return data

@app.post("/api/retrosynthesis")
async def run_retro(req: RetroRequest):
    return RetroManager.run_retrosynthesis(req.smiles)


@app.post("/api/train")
async def start_training(pdb_id: str = Form(...), file: UploadFile = File(...)):
    if training_state["is_running"]: 
        raise HTTPException(400, "Training is already in progress.")
    
    upload_path = os.path.join(BASE_DIR, "data", f"upload_{file.filename}")
    with open(upload_path, "wb+") as f:
        shutil.copyfileobj(file.file, f)
    
    # Run training in background thread
    threading.Thread(target=run_training_task, args=(upload_path, pdb_id)).start()
    return {"status": "started"}

@app.get("/api/training/status")
async def get_status():
    return training_state

@app.post("/api/docking/run")
async def api_run_docking(req: DockingRequest):
    """
    Runs Vina docking for a specific project.
    """
    result = DockingManager.run_docking(req.project_id, req.smiles)
    if not result["success"]:
        raise HTTPException(status_code=500, detail=result.get("error", "Docking failed"))
    return result

@app.get("/api/feudal/status/{project_id}")
async def get_feudal_status(project_id: str):
    log_path = os.path.join(PROJECTS_DIR, project_id, "feudal_logs", "progress.json")
    hist_path = os.path.join(PROJECTS_DIR, project_id, "feudal_logs", f"run_{project_id}.json")
    
    data = {"logs": [], "history": []}
    
    if os.path.exists(log_path):
        with open(log_path, "r") as f: data["logs"] = json.load(f)
    
    if os.path.exists(hist_path):
        with open(hist_path, "r") as f: data["history"] = json.load(f)
            
    return data

@app.post("/api/feudal/optimize")
async def start_feudal_task(req: FeudalRequest, background_tasks: BackgroundTasks):
    feudal = FeudalOptimizationManager.get_instance()
    # We run this as a background task because it takes 1-2 minutes
    background_tasks.add_task(feudal.run_optimization, req.project_id, req.smiles, req.steps, req.batch_size)
    return {"status": "started", "message": "Optimization loop running in background"}

@app.post("/api/feudal/pareto-rank")
async def get_pareto(req: ParetoRequest):
    # Construct path to the optimization log generated by the feudal task
    log_path = os.path.join(PROJECTS_DIR, req.project_id, "feudal_logs", f"run_{req.project_id}.json")
    
    if not os.path.exists(log_path):
        raise HTTPException(status_code=404, detail="Optimization logs not found. Run optimization first.")
    
    try:
        with open(log_path, "r") as f:
            history = json.load(f)
        
        # Calculate the winner using the weights provided by the UI
        winner = calculate_pareto_winner(history, req.weights)
        return winner
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ranking failed: {str(e)}")
from services.pdb_service import PDBManager

@app.get("/api/pdb/fetch/{pdb_id}")
async def fetch_pdb(pdb_id: str):
    path = PDBManager.fetch_from_rcsb(pdb_id)
    if not path: raise HTTPException(404, "PDB not found in RCSB")
    return {"status": "success", "filename": os.path.basename(path)}

@app.post("/api/p2rank/run")
async def run_p2rank_api(pdb_filename: str, project_id: str, background_tasks: BackgroundTasks):
    def update_logs(msg):
        # Reuse your existing log_event system from feudal RL
        # (Assuming you use a shared state or file for logs)
        print(f"[P2Rank Log]: {msg}")

    background_tasks.add_task(PDBManager.run_p2rank, pdb_filename, project_id, update_logs)
    return {"status": "started"}

@app.get("/api/p2rank/results")
async def get_p2rank_results(pdb_filename: str, project_id: str):
    results = PDBManager.get_p2rank_results(pdb_filename, project_id)
    if not results: raise HTTPException(404, "Results not found")
    return results
from rdkit import Chem
from rdkit.Chem import Draw
from fastapi.responses import Response
import io
@app.get("/api/render")
async def render_molecule(smiles: str):
    mol = Chem.MolFromSmiles(smiles)
    img = Draw.MolToImage(mol, size=(300, 300))
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    return Response(content=buf.getvalue(), media_type="image/png")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)