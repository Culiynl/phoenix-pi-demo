import os
import shutil
import json
import threading
from fastapi import FastAPI, HTTPException, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

from config import IMG_DIR, BASE_DIR, DATA_DIR, PROJECTS_DIR 
from schemas import (
    DiseaseQuery, TargetRequest, RetroRequest, 
    DockingRequest, FeudalRequest, ParetoRequest
)
from state import training_state
# Import Services
from services.llm_service import review_literature
from services.bio_service import RetroManager, fetch_chembl_data
from services.training_runner import run_training_task
from services.docking_service import DockingManager
from services.feudal_service import FeudalOptimizationManager 
from services.analysis_service import calculate_pareto_winner

app = FastAPI()

app.mount("/static", StaticFiles(directory=DATA_DIR), name="static")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/api/review")
async def api_review_literature(query: DiseaseQuery):
    try:
        return review_literature(query)
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chembl/download")
async def api_get_chembl_data(req: TargetRequest):
    data = fetch_chembl_data(req.target_name)
    if not data:
        raise HTTPException(404, "Target not found or ChEMBL unavailable")
    return data

@app.post("/api/retrosynthesis")
async def run_retro(req: RetroRequest):
    return RetroManager.run_retrosynthesis(req.smiles)


@app.post("/api/train")
async def start_training(pdb_id: str = Form(...), file: UploadFile = File(...)):
    if training_state["is_running"]: 
        raise HTTPException(400, "Training is already in progress.")
    
    upload_path = os.path.join(BASE_DIR, "data", f"upload_{file.filename}")
    with open(upload_path, "wb+") as f:
        shutil.copyfileobj(file.file, f)
    
    # Run training in background thread
    threading.Thread(target=run_training_task, args=(upload_path, pdb_id)).start()
    return {"status": "started"}

@app.get("/api/training/status")
async def get_status():
    return training_state

@app.post("/api/docking/run")
async def api_run_docking(req: DockingRequest):
    """
    Runs Vina docking for a specific project.
    """
    result = DockingManager.run_docking(req.project_id, req.smiles)
    if not result["success"]:
        raise HTTPException(status_code=500, detail=result.get("error", "Docking failed"))
    return result

@app.post("/api/feudal/optimize")
async def start_feudal_task(req: FeudalRequest):
    # This should be a background task
    feudal = FeudalOptimizationManager.get_instance()
    history, log_file = feudal.run_optimization(req.project_id, req.smiles)
    return {"status": "complete", "history": history}

@app.post("/api/feudal/pareto-rank")
async def get_pareto(req: ParetoRequest):
    # Construct path to the optimization log generated by the feudal task
    log_path = os.path.join(PROJECTS_DIR, req.project_id, "feudal_logs", f"run_{req.project_id}.json")
    
    if not os.path.exists(log_path):
        raise HTTPException(status_code=404, detail="Optimization logs not found. Run optimization first.")
    
    try:
        with open(log_path, "r") as f:
            history = json.load(f)
        
        # Calculate the winner using the weights provided by the UI
        winner = calculate_pareto_winner(history, req.weights)
        return winner
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ranking failed: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)